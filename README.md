 

# 高性能定时器设计

基于时间轮的定时器，用于web服务器中的客户连接的定时。

## Time_wheel 1.0

第一版本来自《linux高性能服务器编程》（游双 著）,整体结构由一个数组和多个链表组成。外层数组中每一个槽代表不同的相对时刻，一共60个槽。利用索引循环，将其打造成一个循环队列。并且有一个整形值代表秒针，记录当前索引，每过1秒钟，秒针值将会加1，秒针转一圈将定时1分钟。而槽中挂着定时器链表，该链表串联着用来管理单个连接的定时器Timer。当秒针指向某一槽时，就会遍历这个槽对应的定时器链表，将定时器总用来记录定时的分钟数的成员减一，表示时间 距离上一次来到这个槽时过去了1分钟，当定时器中该记录该成员的值减到0，就会销毁定时器，表示定时结束。

## Time_wheel 2.0

我对在第一版本进行了修改，利用stl中的vector和list替代原著中的数组和普通链表，利用迭代器管理定时器。

## Time_wheel 3.0

 第三版本是对第二版本的改进，针对于定时器链表的频繁的插入和删除，提出利用构建简单的内存池来减少开销，将第二版本的vector<list<Timer>>时间轮整体结构改成vector<vector<Timer>>结构，用vector替换list，来存储Timer定时器。在内层vector上打造两条双向“链表“，并非真正的链表，而是用索引替换指针，来连接vector上的元素，内层vector上每一个Timer元素，都有一个前向索引和一个后向索引，用来记录前一个Timer的索引，和后一个Timer的索引。0号元素是空闲链表头，1号元素是忙碌链表头，初始情况下这两个链表头的前向和后向索引都指向他自己。

删除一个定时器，并不会销毁定时器，而是将定时器从忙碌链表中摘下，利用头插法，插入到空闲链表中。

当要插入定时器时，先判断空闲链表是否为空，如果非空，就从空闲链表中摘下首元素，利用重载的operator=函数，直接把旧的定时器的成员的修改值为新的定时器，免去了内存分配和初始化，（因为空闲链表上的定时器都是从忙碌链表中回收的，也就是说之前就被构造好了，而新的Timer结果和旧的一致，所以只需要修改值就好了）。如果空闲链表为空，那么就利用push_back函数，插入定时器，然后把新Timer插入的元素利用头插发插入到忙碌链表中。